{"slots":{"0":{"name":"spacefueltank_1","type":{"events":[],"methods":[]}},"1":{"name":"spacefueltank_2","type":{"events":[],"methods":[]}},"2":{"name":"atmofueltank_1","type":{"events":[],"methods":[]}},"3":{"name":"atmofueltank_2","type":{"events":[],"methods":[]}},"4":{"name":"core","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"10":{"name":"slot11","type":{"events":[],"methods":[]}},"11":{"name":"slot12","type":{"events":[],"methods":[]}},"12":{"name":"slot13","type":{"events":[],"methods":[]}},"13":{"name":"slot14","type":{"events":[],"methods":[]}},"14":{"name":"slot15","type":{"events":[],"methods":[]}},"15":{"name":"slot16","type":{"events":[],"methods":[]}},"16":{"name":"slot17","type":{"events":[],"methods":[]}},"17":{"name":"slot18","type":{"events":[],"methods":[]}},"18":{"name":"slot19","type":{"events":[],"methods":[]}},"19":{"name":"slot20","type":{"events":[],"methods":[]}},"20":{"name":"slot21","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hide() end\nif warpdrive ~= nil then warpdrive.hide() end\nif gyro ~= nil then gyro.hide() end\ncore.hide()\nNav.control.switchOffHeadlights()\n","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"0"},{"code":"-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\n\nweapon = {}\nweapon_size = 0\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n\nspacefueltank = {}\nspacefueltank[1] = spacefueltank_1\nspacefueltank[2] = spacefueltank_2\nspacefueltank_size = 2\n\nradar = {}\nradar_size = 0\n\natmofueltank = {}\natmofueltank[1] = atmofueltank_1\natmofueltank[2] = atmofueltank_2\natmofueltank_size = 2\n-- End of auto-generated code\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(4)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\ncore.show()\n_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = true\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\nif antigrav ~= nil then antigrav.show() end\nif warpdrive ~= nil then warpdrive.show() end\nif gyro ~= nil then gyro.show() end\n\n-- freeze the player in he is remote controlling the construct\nif Nav.control.isRemoteControlled() == 1 then\n    system.freeze(1)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n\nunit.setTimer(\"updateHud\", 1/30)","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"1"},{"code":"\nupdateHud()\n\nlocal velocity = core.getWorldVelocity()\nlocal velMag = vec3(velocity):len()\nlocal sys = galaxyReference[0]\nlocal planet = sys:closestBody(core.getConstructWorldPos())\nlocal kepPlanet = Keplers()(planet)\nlocal orbit = kepPlanet:orbitalParameters(core.getConstructWorldPos(), velocity)\nif orbit ~= nil then\n\tShowOrbitPanel()\n\n\tsystem.updateData(orbitHeaderText,'{\"label\": \"Planet\", \"value\": \"' .. planet.name .. '\", \"unit\":\"\"}')\n\t\n\tif orbit.apoapsis == nil then\n\t\tsystem.updateData(widgetApoapsisText, '{\"label\": \"Apoapsis\", \"value\": \"N/A\", \"unit\":\"\"}')\n\telse\n\t\tsystem.updateData(widgetApoapsisText, '{\"label\": \"Apoapsis\", \"value\": \"' .. getDistanceDisplayString(orbit.apoapsis.altitude) ..  '\", \"unit\":\"\"}')\n\tend\n\t\n\tsystem.updateData(widgetPeriapsisText, '{\"label\": \"Periapsis\", \"value\": \"' .. getDistanceDisplayString(orbit.periapsis.altitude) .. '\", \"unit\":\"\"}')\n\t\n\tif orbit.apoapsis == nil then\n\t\tsystem.updateData(widgetMinSpeedText, '{\"label\": \"Min Speed\", \"value\": \"N/A\", \"unit\":\"\"}')\n\telse\n\t\tsystem.updateData(widgetMinSpeedText, '{\"label\": \"Min Speed\", \"value\": \"' .. getSpeedDisplayString(orbit.apoapsis.speed) .. '\", \"unit\":\"\"}')\n\tend\n\t\n\tsystem.updateData(widgetMaxSpeedText, '{\"label\": \"Max Speed\", \"value\": \"' .. getSpeedDisplayString(orbit.periapsis.speed) .. '\", \"unit\":\"\"}')\n\tsystem.updateData(widgetEccentricityText, '{\"label\": \"Eccentricity\", \"value\": \"' .. round(orbit.eccentricity,2) .. '\", \"unit\":\"\"}')\t\n\t\nelse\n\tHideOrbitPanel()\nend\n\nif AutopilotTargetName ~= \"None\" then\n\n\tShowInterplanetaryPanel()\n\t\n\tsystem.updateData(interplanetaryHeaderText, '{\"label\": \"Target\", \"value\": \"' .. AutopilotTargetName .. '\", \"unit\":\"\"}')\n\tlocal travelTime = GetAutopilotTravelTime() -- This also sets AutopilotDistance so we don't have to calc it again\n\tlocal distance = AutopilotDistance\n\tlocal brakeDistance, brakeTime = GetAutopilotBrakeDistanceAndTime(velMag)\n\tlocal maxBrakeDistance, maxBrakeTime = GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)\n\t\n\tsystem.updateData(widgetDistanceText, '{\"label\": \"Distance\", \"value\": \"' .. getDistanceDisplayString(distance) .. '\", \"unit\":\"\"}')\n\tsystem.updateData(widgetTravelTimeText, '{\"label\": \"Travel Time\", \"value\": \"' .. FormatTimeString(travelTime) .. '\", \"unit\":\"\"}')\n\tsystem.updateData(widgetCurBrakeDistanceText, '{\"label\": \"Cur Brake Distance\", \"value\": \"' .. getDistanceDisplayString(brakeDistance) .. '\", \"unit\":\"\"}')\n\tsystem.updateData(widgetCurBrakeTimeText, '{\"label\": \"Cur Brake Time\", \"value\": \"' .. FormatTimeString(brakeTime) .. '\", \"unit\":\"\"}')\n\tsystem.updateData(widgetMaxBrakeDistanceText, '{\"label\": \"Max Brake Distance\", \"value\": \"' .. getDistanceDisplayString(maxBrakeDistance) .. '\", \"unit\":\"\"}')\n\tsystem.updateData(widgetMaxBrakeTimeText, '{\"label\": \"Max Brake Time\", \"value\": \"' .. FormatTimeString(maxBrakeTime) .. '\", \"unit\":\"\"}')\n\nelse\n\tHideInterplanetaryPanel()\nend","filter":{"args":[{"value":"updateHud"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"if antigrav ~= nil then antigrav.toggle() end","filter":{"args":[{"value":"antigravity"}],"signature":"actionStart(antigravity)","slotKey":"-2"},"key":"3"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)","filter":{"args":[{"value":"speeddown"}],"signature":"actionLoop(speeddown)","slotKey":"-2"},"key":"4"},{"code":"if warpdrive ~= nil then warpdrive.activateWarp() end","filter":{"args":[{"value":"warp"}],"signature":"actionStart(warp)","slotKey":"-2"},"key":"5"},{"code":"if brakeInput == 0 then\n    brakeInput = 1\nelse\n    brakeInput = 0\nend\n\n-- Uncomment the following if you want cruise control to lower speed when you brake\n--local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\n--if (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n--    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n--    if (math.abs(targetSpeed) > constants.epsilon) then\n--        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n--    end\n--end\n","filter":{"args":[{"value":"brake"}],"signature":"actionStart(brake)","slotKey":"-2"},"key":"6"},{"code":"--brakeInput = brakeInput - 1","filter":{"args":[{"value":"brake"}],"signature":"actionStop(brake)","slotKey":"-2"},"key":"7"},{"code":"local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"actionLoop(brake)","slotKey":"-2"},"key":"8"},{"code":"Nav:toggleBoosters()","filter":{"args":[{"value":"booster"}],"signature":"actionStart(booster)","slotKey":"-2"},"key":"9"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)","filter":{"args":[{"value":"speedup"}],"signature":"actionStart(speedup)","slotKey":"-2"},"key":"10"},{"code":"Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)","filter":{"args":[{"value":"stopengines"}],"signature":"actionStart(stopengines)","slotKey":"-2"},"key":"11"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)","filter":{"args":[{"value":"speedup"}],"signature":"actionLoop(speedup)","slotKey":"-2"},"key":"12"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)","filter":{"args":[{"value":"speeddown"}],"signature":"actionStart(speeddown)","slotKey":"-2"},"key":"13"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"actionStart(strafeleft)","slotKey":"-2"},"key":"14"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"actionStop(strafeleft)","slotKey":"-2"},"key":"15"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n","filter":{"args":[{"value":"up"}],"signature":"actionStart(up)","slotKey":"-2"},"key":"16"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"up"}],"signature":"actionStop(up)","slotKey":"-2"},"key":"17"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n","filter":{"args":[{"value":"down"}],"signature":"actionStart(down)","slotKey":"-2"},"key":"18"},{"code":"pitchInput = 0\nrollInput = 0\nyawInput = 0\nif unit.getAtmosphereDensity() > 0 then\n\tbrakeInput = 1\nelse\n     brakeInput = 0\nend\n\n\n-- Written by Dimencia.  Linked sources where appropriate, most have been modified\n\nPrimaryR = 124 --export: Primary HUD color\nPrimaryG = 252 --export: Primary HUD color\nPrimaryB = 0 --export: Primary HUD color\n\n\nfunction ShowOrbitPanel()\n-- Orbit info\n\tif panelOrbit == nil then\n\t\tpanelOrbit = system.createWidgetPanel(\"Orbital Information\")\n\t\torbitHeader = system.createWidget(panelOrbit, \"value\")\n\t\torbitHeaderText = system.createData('{\"label\": \"Planet\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(orbitHeaderText, orbitHeader)\n\n\t\twidgetApoapsis = system.createWidget(panelOrbit, \"value\")\n\t\twidgetApoapsisText = system.createData('{\"label\": \"Apoapsis\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetApoapsisText, widgetApoapsis)\n\n\t\twidgetPeriapsis = system.createWidget(panelOrbit, \"value\")\n\t\twidgetPeriapsisText = system.createData('{\"label\": \"Periapsis\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetPeriapsisText, widgetPeriapsis)\n\n\t\twidgetMinSpeed = system.createWidget(panelOrbit, \"value\")\n\t\twidgetMinSpeedText = system.createData('{\"label\": \"Min Speed\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetMinSpeedText, widgetMinSpeed)\n\n\t\twidgetMaxSpeed = system.createWidget(panelOrbit, \"value\")\n\t\twidgetMaxSpeedText = system.createData('{\"label\": \"Max Speed\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetMaxSpeedText, widgetMaxSpeed)\n\n\t\twidgetEccentricity = system.createWidget(panelOrbit, \"value\")\n\t\twidgetEccentricityText = system.createData('{\"label\": \"Eccentricity\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetEccentricityText, widgetEccentricity)\n\tend\nend\n\n\nfunction ShowInterplanetaryPanel()\n-- Interplanetary helper\n\tif panelInterplanetary == nil then\n\t\tpanelInterplanetary = system.createWidgetPanel(\"Interplanetary Helper\")\n\t\tinterplanetaryHeader = system.createWidget(panelInterplanetary, \"value\")\n\t\tinterplanetaryHeaderText = system.createData('{\"label\": \"Target Planet\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(interplanetaryHeaderText, interplanetaryHeader)\n\n\t\twidgetDistance = system.createWidget(panelInterplanetary, \"value\")\n\t\twidgetDistanceText = system.createData('{\"label\": \"Distance\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetDistanceText, widgetDistance)\n\n\t\twidgetTravelTime = system.createWidget(panelInterplanetary, \"value\")\n\t\twidgetTravelTimeText = system.createData('{\"label\": \"Travel Time\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetTravelTimeText, widgetTravelTime)\n\n\t\twidgetCurBrakeDistance = system.createWidget(panelInterplanetary, \"value\")\n\t\twidgetCurBrakeDistanceText = system.createData('{\"label\": \"Cur Brake Distance\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance)\n\n\t\twidgetCurBrakeTime = system.createWidget(panelInterplanetary, \"value\")\n\t\twidgetCurBrakeTimeText = system.createData('{\"label\": \"Cur Brake Time\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)\n\n\t\twidgetMaxBrakeDistance = system.createWidget(panelInterplanetary, \"value\")\n\t\twidgetMaxBrakeDistanceText = system.createData('{\"label\": \"Max Brake Distance\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetMaxBrakeDistanceText, widgetMaxBrakeDistance)\n\n\t\twidgetMaxBrakeTime = system.createWidget(panelInterplanetary, \"value\")\n\t\twidgetMaxBrakeTimeText = system.createData('{\"label\": \"Max Brake Time\", \"value\": \"N/A\", \"unit\":\"\"}')\n\t\tsystem.addDataToWidget(widgetMaxBrakeTimeText, widgetMaxBrakeTime)\n\tend\nend\n\nfunction HideOrbitPanel()\n\tsystem.destroyWidgetPanel(panelOrbit)\n\tpanelOrbit = nil\nend\n\nfunction HideInterplanetaryPanel()\n\tsystem.destroyWidgetPanel(panelInterplanetary)\n\tpanelInterplanetary = nil\nend\n\n\n\n-- HUD - https://github.com/Rezoix/DU-hud with modifications\n\nsystem.showScreen(1)\n\nfunction getRelativePitch(velocity) \n    velocity = vec3(velocity)\n    local pitch = -math.deg(math.atan(velocity.y, velocity.z)) + 180\n    -- This is 0-360 where 0 is straight up\n    pitch = pitch - 90\n    -- So now 0 is straight, but we can now get angles up to 420\n    if pitch < 0 then\n       pitch = 360 + pitch \n    end \n    -- Now, if it's greater than 180, say 190, make it go to like -170\n    if pitch > 180 then\n       pitch = -180 + (pitch-180) \n    end\n    -- And it's backwards.  \n    return -pitch\nend\n\nfunction getRelativeYaw(velocity) \n    velocity = vec3(velocity)\n    return math.deg(math.atan(velocity.y, velocity.x)) - 90\nend\n\nfunction updateHud()\n    local altitude = core.getAltitude()\n    local velocity = core.getVelocity()\n    local speed = vec3(velocity):len()\n    local worldV = vec3(core.getWorldVertical())\n    local constrF = vec3(core.getConstructWorldOrientationForward())\n    local constrR = vec3(core.getConstructWorldOrientationRight())\n    local constrV = vec3(core.getConstructWorldOrientationUp())\n\n    local pitch = getPitch(worldV, constrF, constrR)--180 - getRoll(worldV, constrR, constrF)\n    local roll = getRoll(worldV, constrF, constrR) --getRoll(worldV, constrF, constrR)\n    local bottomText = \"ROLL\"\n    local mode = 0\n\n    if (unit.getAtmosphereDensity() == 0) then\n        mode = 1\n    else\n        mode = 0\n    end\n\t\n    if (mode == 1) then\n        if (speed > 5) then\n            pitch = getRelativePitch(velocity)\n            roll = getRelativeYaw(velocity)\n        else\n            pitch = 0\n            roll = 0\n        end\n        bottomText = \"YAW\"\n        \n    end\n\n    local content = [[\n    <head>\n        <style>\n            body {margin: 0}\n            svg {display:block; position:absolute; top:0; left:0} \n            .majorLine {stroke:rgb(]] .. math.floor(PrimaryR *0.8 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.8 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.8 + 0.5) .. [[);opacity:0.7;stroke-width:3;fill-opacity:0;}\n            .minorLine {stroke:rgb(]] .. math.floor(PrimaryR *0.8 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.8 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.8 + 0.5) .. [[);opacity:0.3;stroke-width:3;fill-opacity:0;}\n            .text {fill:rgb(]] .. math.floor(PrimaryR *0.8 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.8 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.8 + 0.5) .. [[);font-family:Montserrat;font-weight:bold}\n            #space {}\n            #ecu {}\n            #atmos {}\n            \n        </style>\n    </head>\n    <body>\n        <svg height=\"100%\" width=\"100%\" viewBox=\"0 0 1920 1080\">\n            <g class=\"majorLine\">\n                <line x1=\"939\" y1=\"537\" x2=\"957\" y2=\"519\"/>\n                <line x1=\"939\" y1=\"543\" x2=\"957\" y2=\"561\"/>\n                <line x1=\"981\" y1=\"537\" x2=\"963\" y2=\"519\"/>\n                <line x1=\"981\" y1=\"543\" x2=\"963\" y2=\"561\"/>\n                <line x1=\"932\" y1=\"540\" x2=\"945\" y2=\"540\"/>\n                <line x1=\"988\" y1=\"540\" x2=\"975\" y2=\"540\"/>\n                <line x1=\"960\" y1=\"512\" x2=\"960\" y2=\"525\"/>\n                <line x1=\"960\" y1=\"568\" x2=\"960\" y2=\"555\"/>\n                <g style=\"opacity:0.2\">\n                    <line x1=\"920\" y1=\"540\" x2=\"840\" y2=\"540\"/>\n                    <line x1=\"1000\" y1=\"540\" x2=\"1080\" y2=\"540\"/>\n                    <line x1=\"960\" y1=\"500\" x2=\"960\" y2=\"470\"/>\n                    <line x1=\"960\" y1=\"580\" x2=\"960\" y2=\"610\"/>\n                </g>\n                <path d=\"M 700 0 L 740 35 Q 960 55 1180 35 L 1220 0\"/>\n                <path d=\"M 792 550 L 785 550 L 785 650 L 792 650\"/>\n            </g>\n            \n            <g>\n                <polygon points=\"782,540 800,535 800,545\" style=\"fill:rgb(]] .. PrimaryR .. \",\" .. PrimaryG .. \",\" .. PrimaryB .. [[);opacity:0.7\"/>\n                <polygon points=\"1138,540 1120,535 1120,545\" style=\"fill:rgb(]] .. PrimaryR .. \",\" .. PrimaryG .. \",\" .. PrimaryB .. [[);opacity:0.7\"/>\n                <polygon points=\"960,725 955,707 965,707\" style=\"fill:rgb(]] .. PrimaryR .. \",\" .. PrimaryG .. \",\" .. PrimaryB .. [[);opacity:0.7\"/>\n            </g>\n                \n            <g class=\"text\">\n                <g font-size=10>\n                    <text x=\"785\" y=\"530\" text-anchor=\"start\">PITCH</text>\n                    <text x=\"1135\" y=\"530\" text-anchor=\"end\">PITCH</text>\n                    <text x=\"960\" y=\"688\" text-anchor=\"middle\">]] .. bottomText .. [[</text>\n                    <text x=\"790\" y=\"660\" text-anchor=\"start\">THRL</text>\n                </g>\n                <g font-size=15>\n                    <text x=\"1020\" y=\"33\" text-anchor=\"middle\" id=\"space\">SPACE</text>\n                    <text x=\"900\" y=\"33\" text-anchor=\"middle\" id=\"atmos\">ATMOS</text>\n                    <text x=\"960\" y=\"35\" text-anchor=\"middle\" id=\"ecu\">ECU</text>\n                </g>\n            \n            </g>]]\n    \n    \n    pitchC = math.floor(pitch)    \n    for i = pitchC-25,pitchC+25 do\n        if (i%10==0) then\n            num = i\n            if (num > 180) then\n                num = -180 + (num-180)\n            elseif (num < -180) then\n                num = 180 + (num+180)\n            end\n\n            content = content..[[<g transform=\"translate(0 ]]..(-i*5 + pitch*5 + 5)..[[)\">\n                <text x=\"745\" y=\"540\" style=\"fill:rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.9 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.9 + 0.5) .. [[);text-anchor:end;font-size:12;font-family:Montserrat;font-weight:bold\">]]..num..[[</text>\n                <text x=\"1175\" y=\"540\" style=\"fill:rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.9 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.9 + 0.5) .. [[);text-anchor:start;font-size:12;font-family:Montserrat;font-weight:bold\">]]..num..[[</text></g>]]\n        end\n\n        len = 5\n        if (i%10==0) then\n            len = 30\n        elseif (i%5==0) then\n            len = 15\n        end\n\n        content = content..[[\n        <g transform=\"translate(0 ]]..(-i*5 + pitch*5)..[[)\">\n            <line x1=\"]]..(780-len)..[[\" y1=\"540\" x2=\"780\" y2=\"540\"style=\"stroke:rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.9 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.9 + 0.5) .. [[);opacity:0.3;stroke-width:3\"/>\n            <line x1=\"]]..(1140+len)..[[\" y1=\"540\" x2=\"1140\" y2=\"540\"style=\"stroke:rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.9 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.9 + 0.5) .. [[);opacity:0.3;stroke-width:3\"/></g>]]\n\n    end\n\n    rollC = math.floor(roll)\n    for i = rollC-35,rollC+35 do\n        if (i%10==0) then\n            local sign = i/math.abs(i)\n            if i == 0 then\n                sign = 0\n            end\n            num = math.abs(i)\n            if (num > 180) then\n                num = 180 + (180-num) \n            end\n            content = content..[[<g transform=\"rotate(]]..(i - roll)..[[,960,460)\">\n            <text x=\"960\" y=\"760\" style=\"fill:rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.9 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.9 + 0.5) .. [[);text-anchor:middle;font-size:12;font-family:Montserrat;font-weight:bold\">]]..math.floor(sign*num+0.5)..[[</text></g>]]\n        end\n\n        len = 5\n        if (i%10==0) then\n            len = 15\n        elseif (i%5==0) then\n            len = 10\n        end\n\n        content = content..[[<g transform=\"rotate(]]..(i - roll)..[[,960,460)\">\n        <line x1=\"960\" y1=\"730\" x2=\"960\" y2=\"]]..(730+len)..[[\" style=\"stroke:rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.9 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.9 + 0.5) .. [[);opacity:0.3;stroke-width:2\"/></g>]]\n    end\n    \n    -- -unit.getThrottle()*0.97\n    content = content..[[<g transform=\"translate(0 ]].. utils.clamp(-unit.getThrottle()*0.97,-1,0)..[[)\">\n            <polygon points=\"788,650 800,647 800,653\" style=\"fill:rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.9 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.9 + 0.5) .. [[);opacity:0.7\"/>\n        </g>]]\n    \n\tif brakeInput == 1 then\n\t\tcontent = content .. \"<text x='960' y='150' font-size='24' fill='red' text-anchor='middle' font-family='Montserrat'>Brake Engaged</text>\"\n\tend\n\t\n\tcontent = content..[[</svg>]]\n\tsystem.setScreen(content)\nend\n\nfunction getPitch(gravityDirection, forward, right)\n    local horizontalForward = gravityDirection:cross(right):normalize_inplace() -- Cross forward?\n    local pitch = math.acos(utils.clamp(horizontalForward:dot(-forward), -1, 1)) * constants.rad2deg -- acos?\n    if horizontalForward:cross(-forward):dot(right) < 0 then pitch = -pitch end -- Cross right dot forward?\n    return pitch\nend\n\n-- Planet Info - https://gitlab.com/JayleBreak/dualuniverse/-/tree/master/DUflightfiles/autoconf/custom with minor modifications\n\n\nfunction Atlas()\n\treturn {\n[0] = {\n  [1]={\n    GM=6930729684,\n    bodyId=1,\n    center={x=17465536.000,y=22665536.000,z=-34464.000},\n    name='Madis',\n    planetarySystemId=0,\n    radius=44300\n  },\n  [2]={\n    GM=157470826617,\n    bodyId=2,\n    center={x=-8.000,y=-8.000,z=-126303.000},\n    name='Alioth',\n    planetarySystemId=0,\n    radius=126068\n  },\n  [3]={\n    GM=11776905000,\n    bodyId=3,\n    center={x=29165536.000,y=10865536.000,z=65536.000},\n    name='Thades',\n    planetarySystemId=0,\n    radius=49000\n  },\n  [4]={\n    GM=14893847582,\n    bodyId=4,\n    center={x=-13234464.000,y=55765536.000,z=465536.000},\n    name='Talemai',\n    planetarySystemId=0,\n    radius=57450\n  },\n  [5]={\n    GM=16951680000,\n    bodyId=5,\n    center={x=-43534464.000,y=22565536.000,z=-48934464.000},\n    name='Feli',\n    planetarySystemId=0,\n    radius=60000\n  },\n  [6]={\n    GM=10502547741,\n    bodyId=6,\n    center={x=52765536.000,y=27165538.000,z=52065535.000},\n    name='Sicari',\n    planetarySystemId=0,\n    radius=51100\n  },\n  [7]={\n    GM=13033380591,\n    bodyId=7,\n    center={x=58665538.000,y=29665535.000,z=58165535.000},\n    name='Sinnen',\n    planetarySystemId=0,\n    radius=54950\n  },\n  [8]={\n    GM=18477723600,\n    bodyId=8,\n    center={x=80865538.000,y=54665536.000,z=-934463.940},\n    name='Teoma',\n    planetarySystemId=0,\n    radius=62000\n  },\n  [9]={\n    GM=18606274330,\n    bodyId=9,\n    center={x=-94134462.000,y=12765534.000,z=-3634464.000},\n    name='Jago',\n    planetarySystemId=0,\n    radius=61590\n  },\n  [10]={\n    GM=78480000,\n    bodyId=10,\n    center={x=17448118.224,y=22966846.286,z=143078.820},\n    name='Madis Moon 1',\n    planetarySystemId=0,\n    radius=10000\n  },\n  [11]={\n    GM=237402000,\n    bodyId=11,\n    center={x=17194626.000,y=22243633.880,z=-214962.810},\n    name='Madis Moon 2',\n    planetarySystemId=0,\n    radius=11000\n  },\n  [12]={\n    GM=265046609,\n    bodyId=12,\n    center={x=17520614.000,y=22184730.000,z=-309989.990},\n    name='Madis Moon 3',\n    planetarySystemId=0,\n    radius=15005\n  },\n  [21]={\n    GM=2118960000,\n    bodyId=21,\n    center={x=457933.000,y=-1509011.000,z=115524.000},\n    name='Alioth Moon 1',\n    planetarySystemId=0,\n    radius=30000\n  },\n  [22]={\n    GM=2165833514,\n    bodyId=22,\n    center={x=-1692694.000,y=729681.000,z=-411464.000},\n    name='Alioth Moon 4',\n    planetarySystemId=0,\n    radius=30330\n  },\n  [26]={\n    GM=68234043600,\n    bodyId=26,\n    center={x=-1404835.000,y=562655.000,z=-285074.000},\n    name='Sanctuary',\n    planetarySystemId=0,\n    radius=83400\n  },\n  [30]={\n    GM=211564034,\n    bodyId=30,\n    center={x=29214402.000,y=10907080.695,z=433858.200},\n    name='Thades Moon 1',\n    planetarySystemId=0,\n    radius=14002\n  },\n  [31]={\n    GM=264870000,\n    bodyId=31,\n    center={x=29404193.000,y=10432768.000,z=19554.131},\n    name='Thades Moon 2',\n    planetarySystemId=0,\n    radius=15000\n  },\n  [40]={\n    GM=141264000,\n    bodyId=40,\n    center={x=-13503090.000,y=55594325.000,z=769838.640},\n    name='Talemai Moon 2',\n    planetarySystemId=0,\n    radius=12000\n  },\n  [41]={\n    GM=106830900,\n    bodyId=41,\n    center={x=-12800515.000,y=55700259.000,z=325207.840},\n    name='Talemai Moon 3',\n    planetarySystemId=0,\n    radius=11000\n  },\n  [42]={\n    GM=264870000,\n    bodyId=42,\n    center={x=-13058408.000,y=55781856.000,z=740177.760},\n    name='Talemai Moon 1',\n    planetarySystemId=0,\n    radius=15000\n  },\n  [50]={\n    GM=499917600,\n    bodyId=50,\n    center={x=-43902841.780,y=22261034.700,z=-48862386.000},\n    name='Feli Moon 1',\n    planetarySystemId=0,\n    radius=14000\n  },\n  [70]={\n    GM=396912600,\n    bodyId=70,\n    center={x=58969616.000,y=29797945.000,z=57969449.000},\n    name='Sinnen Moon 1',\n    planetarySystemId=0,\n    radius=17000\n  },\n  [100]={\n    GM=13975172474,\n    bodyId=100,\n    center={x=98865536.000,y=-13534464.000,z=-934461.990},\n    name='Lacobus',\n    planetarySystemId=0,\n    radius=55650\n  },\n  [101]={\n    GM=264870000,\n    bodyId=101,\n    center={x=98905288.170,y=-13950921.100,z=-647589.530},\n    name='Lacobus Moon 3',\n    planetarySystemId=0,\n    radius=15000\n  },\n  [102]={\n    GM=444981600,\n    bodyId=102,\n    center={x=99180968.000,y=-13783862.000,z=-926156.400},\n    name='Lacobus Moon 1',\n    planetarySystemId=0,\n    radius=18000\n  },\n  [103]={\n    GM=211503600,\n    bodyId=103,\n    center={x=99250052.000,y=-13629215.000,z=-1059341.400},\n    name='Lacobus Moon 2',\n    planetarySystemId=0,\n    radius=14000\n  },\n  [110]={\n    GM=9204742375,\n    bodyId=110,\n    center={x=14165536.000,y=-85634465.000,z=-934464.300},\n    name='Symeon',\n    planetarySystemId=0,\n    radius=49050\n  },\n  [120]={\n    GM=7135606629,\n    bodyId=120,\n    center={x=2865536.700,y=-99034464.000,z=-934462.020},\n    name='Ion',\n    planetarySystemId=0,\n    radius=44950\n  },\n  [121]={\n    GM=106830900,\n    bodyId=121,\n    center={x=2472916.800,y=-99133747.000,z=-1133582.800},\n    name='Ion Moon 1',\n    planetarySystemId=0,\n    radius=11000\n  },\n  [122]={\n    GM=176580000,\n    bodyId=122,\n    center={x=2995424.500,y=-99275010.000,z=-1378480.700},\n    name='Ion Moon 2',\n    planetarySystemId=0,\n    radius=15000\n  }  \n }\n}\n\nend\n\nfunction PlanetRef() \n--[[ \n  Provide coordinate transforms and access to kinematic related parameters\n  Author: JayleBreak\n\n  Usage (unit.start):\n  PlanetaryReference = require('planetref')\n  galaxyReference = PlanetaryReference(referenceTableSource)\n  helios = galaxyReference[0] -- PlanetaryReference.PlanetarySystem instance\n  alioth = helios[2]          -- PlanetaryReference.BodyParameters instance\n\n  Methods:\n    PlanetaryReference:getPlanetarySystem - based on planetary system ID.\n    PlanetaryReference.isMapPosition - 'true' if an instance of 'MapPosition'\n    PlanetaryReference.createBodyParameters - for entry into reference table\n    PlanetaryReference.BodyParameters - a class containing a body's information.\n    PlanetaryReference.MapPosition - a class for map coordinates\n    PlanetaryReference.PlanetarySystem - a container for planetary system info.\n\n    PlanetarySystem:castIntersections - from a position in a given direction.\n    PlanetarySystem:closestBody - to the specified coordinates.\n    PlanetarySystem:convertToBodyIdAndWorldCoordinates - from map coordinates.\n    PlanetarySystem:getBodyParameters - from reference table.\n    PlanetarySystem:getPlanetarySystemId - for the instance.\n\n    BodyParameters:convertToWorldCoordinates - from map coordinates\n    BodyParameters:convertToMapPosition - from world coordinates\n    BodyParameters:getAltitude - of world coordinates\n    BodyParameters:getDistance - from center to world coordinates\n    BodyParameters:getGravity - at a given position in world coordinates.\n\n  Description\n  An instance of the 'PlanetaryReference' \"class\" can contain transform and\n  kinematic reference information for all planetary systems in DualUniverse.\n  Each planetary system is identified by a numeric identifier. Currently,\n  the only planetary system, Helios, has the identifier: zero. This \"class\"\n  supports the indexing ('[]') operation which is equivalent to the\n  use of the 'getPlanetarySystem' method. It also supports the 'pairs()'\n  method for iterating over planetary systems.\n  \n  An instance of the 'PlanetarySystem' \"class\" contains all reference\n  information for a specific system. It supports the indexing ('[]') and\n  'pairs()' functions which allows iteration over each \"body\" in the\n  system where the key is the numeric body ID. It also supports the\n  'tostring()' method.\n\n  An instance of the 'BodyParameters' \"class\" contains all reference\n  information for a single celestial \"body\" (a moon or planet). It supports\n  the 'tostring()' method, and contains the data members:\n          planetarySystemId - numeric planetary system ID\n          bodyId            - numeric body ID\n          radius            - radius of the body in meters (zero altitude)\n          center            - world coordinates of the body's center position\n          GM                - the gravitation parameter (g = GM/radius^2)\n  Note that the user is allowed to add custom fields (e.g. body name), but\n  should insure that complex table values have the '__tostring' metamethod\n  implemented.\n\n  Transform and Kinematics:\n  \"World\" coordinates is a cartesian coordinate system with an origin at an\n  arbitrary fixed point in a planetary system and with distances measured in\n  meters. The coordinates are expressible either as a simple table of 3 values\n  or an instance of the 'vec3' class.  In either case, the planetary system\n  identity is implicit.\n\n  \"Map\" coordinates is a geographic coordinate system with an origin at the\n  center of an identified (by a numeric value) celestial body which is a\n  member of an identified (also a numeric value) planetary system. Note that\n  the convention that latitude, longitude, and altitude values will be the\n  position's x, y, and z world coordinates in the special case of body ID 0.\n\n  The kinematic parameters in the reference data permit calculations of the\n  gravitational attraction of the celestial body on other objects.\n\n  Reference Data:\n  This is an example of reference data with a single entry assigned to\n  planetary system ID 0, and body ID 2 ('Alioth'):\n    referenceTable = {\n          [0] = { [2] = { planetarySystemId = 0,\n                          bodyId = 2,\n                          radius = 126068,\n                          center = vec3({x=-8, y=-8, z=-126303}),\n                          GM = 1.572199+11 } -- as in F=-GMm/r^2\n          }\n      }\n    ref=PlanetaryReference(referenceTable)\n\n  Collecting Reference Data:\n  A combination of information from the \"Map\" screen in the DU user interface,\n  and values reported by the DU Lua API can be the source of the reference\n  table's data (planetarySystemId, bodyId, and surfaceArea is from the user\n  interface):\n    referenceTable = {}\n    referenceTable[planetarySystemId][bodyId] =\n         PlanetaryReference.createBodyParameters(planetarySystemId,\n                                                 bodyId,\n                                                 surfaceArea,\n                                                 core.getConstructWorldPos(),\n                                                 core.getWorldVertical(),\n                                                 core.getAltitude(),\n                                                 core.g())\n\n\n  Adapting Data Sources:\n  Other sources of data can be adapted or converted. An example of adapting a\n  table, defined in the file: 'planets.lua', containing information on a single\n  planetary system and using celestial body name as the key follows (note that\n  a 'name' field is added to the BodyParameters instance transparently after\n  construction, and the '__pairs' meta function is required to support the\n  'closestBody' and '__tostring' methods):\n    ref=PlanetaryReference(\n        {[0] = setmetatable(require('planets'),\n                        { __index = function(bodies, bodyId)\n                             for _,v in pairs(bodies) do\n                                 if v and v.bodyId == bodyId then return v end\n                             end\n                             return nil\n                           end,\n                         __pairs = function(bodies)\n                             return function(t, k)\n                                     local nk, nv = next(t, k)\n                                     if nv then\n                                         local GM = nv.gravity * nv.radius^2\n                                         local bp = BodyParameters(0,\n                                                                   nv.id,\n                                                                   nv.radius,\n                                                                   nv.pos,\n                                                                   GM)\n                                         bp.name = nk\n                                         return nk, bp\n                                    end\n                                    return nk, nv\n                                 end, bodies, nil\n                           end })\n    })\n    \n  Converting Data Sources:\n  An instance of 'PlanetaryReference' that has been adapted to a data source\n  can be used to convert that source to simple table. For example,\n  using the adapted instance shown above:\n    load('convertedData=' .. tostring(ref))()\n    newRef=PlanetaryReference(convertedData)\n\n  Also See: kepler.lua\n  ]]--\n\n--[[                    START OF LOCAL IMPLEMENTATION DETAILS             ]]--\n\n-- Type checks\n\nlocal function isNumber(n)  return type(n)           == 'number' end\nlocal function isSNumber(n) return type(tonumber(n)) == 'number' end\nlocal function isTable(t)   return type(t)           == 'table'  end\nlocal function isString(s)  return type(s)           == 'string' end\nlocal function isVector(v)  return isTable(v)\n                                    and isNumber(v.x and v.y and v.z) end\n\nlocal function isMapPosition(m) return isTable(m) and isNumber(m.latitude  and\n                                                               m.longitude and\n                                                               m.altitude  and\n                                                               m.bodyId    and\n                                                               m.systemId) end\n\n-- Constants\n\nlocal deg2rad    = math.pi/180\nlocal rad2deg    = 180/math.pi\nlocal epsilon    = 1e-10\nlocal num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\nlocal posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..\n                   num ..  ',' .. num .. '}'\n\n-- Utilities\n\nlocal utils  = require('cpml.utils')\nlocal vec3   = require('cpml.vec3')\nlocal clamp  = utils.clamp\n\nlocal function float_eq(a,b)\n    if a == 0 then return math.abs(b) < 1e-09 end\n    if b == 0 then return math.abs(a) < 1e-09 end\n    return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon\nend\n\nlocal function formatNumber(n)\n    local result = string.gsub(\n                    string.reverse(string.format('%.4f',n)),\n                    '^0*%.?','')\n    return result == '' and '0' or string.reverse(result)\nend\n\nlocal function formatValue(obj)\n    if isVector(obj) then\n        return string.format('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z)\n    end\n\n    if isTable(obj) and not getmetatable(obj) then\n        local list = {}\n        local nxt  = next(obj)\n\n        if type(nxt) == 'nil' or nxt == 1 then -- assume this is an array\n            list = obj\n        else\n            for k,v in pairs(obj) do\n                local value = formatValue(v)\n                if type(k) == 'number' then\n                    table.insert(list, string.format('[%s]=%s', k, value))\n                else\n                    table.insert(list, string.format('%s=%s',   k, value))\n                end\n            end\n        end\n        return string.format('{%s}', table.concat(list, ','))\n    end\n\n    if isString(obj) then\n        return string.format(\"'%s'\", obj:gsub(\"'\",[[\\']]))\n    end\n    return tostring(obj)\nend\n\n-- CLASSES\n\n-- BodyParameters: Attributes of planetary bodies (planets and moons)\n\nlocal BodyParameters = {}\nBodyParameters.__index = BodyParameters\nBodyParameters.__tostring =\n    function(obj, indent)\n        local sep = indent or ''\n        local keys = {}\n        for k in pairs(obj) do table.insert(keys, k) end\n        table.sort(keys)\n        local list = {}\n        for _, k in ipairs(keys) do\n            local value = formatValue(obj[k])\n            if type(k) == 'number' then\n                table.insert(list, string.format('[%s]=%s', k, value))\n            else\n                table.insert(list, string.format('%s=%s', k, value))\n            end\n        end\n        if indent then\n            return string.format('%s%s',\n                                 indent,\n                                 table.concat(list, ',\\n' .. indent))\n        end\n        return string.format('{%s}', table.concat(list, ','))\n    end\nBodyParameters.__eq = function(lhs, rhs)\n        return lhs.planetarySystemId == rhs.planetarySystemId and\n               lhs.bodyId            == rhs.bodyId            and\n               float_eq(lhs.radius, rhs.radius)               and\n               float_eq(lhs.center.x, rhs.center.x)           and\n               float_eq(lhs.center.y, rhs.center.y)           and\n               float_eq(lhs.center.z, rhs.center.z)           and\n               float_eq(lhs.GM, rhs.GM)\n    end\n\nlocal function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)\n    -- 'worldCoordinates' can be either table or vec3\n    assert(isSNumber(systemId),\n           'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))\n    assert(isSNumber(bodyId),\n           'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n    assert(isSNumber(radius),\n           'Argument 3 (radius) must be a number:' .. type(radius))\n    assert(isTable(worldCoordinates),\n           'Argument 4 (worldCoordinates) must be a array or vec3.' ..\n           type(worldCoordinates))\n    assert(isSNumber(GM),\n           'Argument 5 (GM) must be a number:' .. type(GM))\n    return setmetatable({planetarySystemId = tonumber(systemId),\n                         bodyId            = tonumber(bodyId),\n                         radius            = tonumber(radius),\n                         center            = vec3(worldCoordinates),\n                         GM                = tonumber(GM) }, BodyParameters)\nend\n\n-- MapPosition: Geographical coordinates of a point on a planetary body.\n\nlocal MapPosition = {}\nMapPosition.__index = MapPosition\nMapPosition.__tostring = function(p)\n        return string.format('::pos{%d,%d,%s,%s,%s}',\n                             p.systemId,\n                             p.bodyId,\n                             formatNumber(p.latitude*rad2deg),\n                             formatNumber(p.longitude*rad2deg),\n                             formatNumber(p.altitude))\n    end\nMapPosition.__eq       = function(lhs, rhs)\n        return lhs.bodyId   == rhs.bodyId              and\n               lhs.systemId == rhs.systemId            and\n               float_eq(lhs.latitude,   rhs.latitude)  and\n               float_eq(lhs.altitude,   rhs.altitude)  and\n               (float_eq(lhs.longitude, rhs.longitude) or\n                float_eq(lhs.latitude, math.pi/2)      or\n                float_eq(lhs.latitude, -math.pi/2))\n    end\n\n-- latitude and longitude are in degrees while altitude is in meters\n\nlocal function mkMapPosition(overload, bodyId, latitude, longitude, altitude)\n    local systemId = overload -- Id or '::pos{...}' string\n\n    if isString(overload) and not longitude and not altitude and\n                              not bodyId    and not latitude then\n        systemId, bodyId, latitude, longitude, altitude =\n                                            string.match(overload, posPattern)\n        assert(systemId, 'Argument 1 (position string) is malformed.')\n    else\n        assert(isSNumber(systemId),\n               'Argument 1 (systemId) must be a number:' .. type(systemId))\n        assert(isSNumber(bodyId),\n               'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n        assert(isSNumber(latitude),\n               'Argument 3 (latitude) must be in degrees:' .. type(latitude))\n        assert(isSNumber(longitude),\n               'Argument 4 (longitude) must be in degrees:' .. type(longitude))\n        assert(isSNumber(altitude),\n               'Argument 5 (altitude) must be in meters:' .. type(altitude))\n    end\n    systemId  = tonumber(systemId)\n    bodyId    = tonumber(bodyId)\n    latitude  = tonumber(latitude)\n    longitude = tonumber(longitude)\n    altitude  = tonumber(altitude)\n\n    if bodyId == 0 then -- this is a hack to represent points in space\n        return setmetatable({latitude  = latitude,\n                             longitude = longitude,\n                             altitude  = altitude,\n                             bodyId    = bodyId,\n                             systemId  = systemId}, MapPosition)\n    end\n    return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),\n                         longitude = deg2rad*(longitude % 360),\n                         altitude  = altitude,\n                         bodyId    = bodyId,\n                         systemId  = systemId}, MapPosition)\nend\n\n-- PlanetarySystem - map body IDs to BodyParameters\n\nlocal PlanetarySystem = {}\nPlanetarySystem.__index = PlanetarySystem\n\nPlanetarySystem.__tostring =\n    function (obj, indent)\n        local sep = indent and (indent .. '  ' )\n        local bdylist = {}\n        local keys = {}\n        for k in pairs(obj) do table.insert(keys, k) end\n        table.sort(keys)\n        for _, bi in ipairs(keys) do\n            bdy = obj[bi]\n            local bdys = BodyParameters.__tostring(bdy, sep)\n            if indent then\n                table.insert(bdylist,\n                             string.format('[%s]={\\n%s\\n%s}',\n                                           bi, bdys, indent))\n            else\n                table.insert(bdylist, string.format('  [%s]=%s', bi, bdys))\n            end\n        end\n        if indent then\n            return string.format('\\n%s%s%s',\n                                 indent,\n                                 table.concat(bdylist, ',\\n' .. indent),\n                                 indent)\n        end\n        return string.format('{\\n%s\\n}', table.concat(bdylist, ',\\n'))\n    end\n\nlocal function mkPlanetarySystem(referenceTable)\n    local atlas = {}\n    local pid\n    for _, v in pairs(referenceTable) do\n        local id = v.planetarySystemId\n\n        if type(id) ~= 'number' then\n            error('Invalid planetary system ID: ' .. tostring(id))\n        elseif pid and id ~= pid then\n            error('Mismatch planetary system IDs: ' .. id .. ' and '\n                  .. pid)\n        end\n        local bid = v.bodyId\n        if type(bid) ~= 'number' then\n            error('Invalid body ID: ' .. tostring(bid))\n        elseif atlas[bid] then\n            error('Duplicate body ID: ' .. tostring(bid))\n        end\n        setmetatable(v.center, getmetatable(vec3.unit_x))\n        atlas[bid] = setmetatable(v, BodyParameters)\n        pid = id\n    end\n    return setmetatable(atlas, PlanetarySystem)\nend\n\n-- PlanetaryReference - map planetary system ID to PlanetarySystem\n\nPlanetaryReference = {}\n\nlocal function mkPlanetaryReference(referenceTable)\n    return setmetatable({ galaxyAtlas = referenceTable or {} },\n                          PlanetaryReference)\nend\n\nPlanetaryReference.__index        = \n    function(t,i)\n        if type(i) == 'number' then\n            local system = t.galaxyAtlas[i]\n            return mkPlanetarySystem(system)\n        end\n        return rawget(PlanetaryReference, i)\n    end\nPlanetaryReference.__pairs        =\n    function(obj)\n        return  function(t, k)\n                    local nk, nv = next(t, k)\n                    return nk, nv and mkPlanetarySystem(nv)\n                end, obj.galaxyAtlas, nil\n    end\nPlanetaryReference.__tostring     =\n    function (obj)\n        local pslist = {}\n        for _,ps in pairs(obj or {}) do\n            local psi = ps:getPlanetarySystemId()\n            local pss = PlanetarySystem.__tostring(ps, '    ')\n            table.insert(pslist,\n                         string.format('  [%s]={%s\\n  }', psi, pss))\n        end\n        return string.format('{\\n%s\\n}\\n', table.concat(pslist,',\\n'))\n    end\n\n\n--[[                       START OF PUBLIC INTERFACE                       ]]--\n\n\n-- PlanetaryReference CLASS METHODS:\n\n--\n-- BodyParameters - create an instance of BodyParameters class\n-- planetarySystemId  [in]: the body's planetary system ID.\n-- bodyId             [in]: the body's ID.\n-- radius             [in]: the radius in meters of the planetary body.\n-- bodyCenter         [in]: the world coordinates of the center (vec3 or table).\n-- GM                 [in]: the body's standard gravitational parameter.\n-- return: an instance of BodyParameters class.\n--\nPlanetaryReference.BodyParameters = mkBodyParameters\n\n--\n-- MapPosition - create an instance of the MapPosition class\n-- overload [in]: either a planetary system ID or a position string ('::pos...')\n-- bodyId [in]:   (ignored if overload is a position string) the body's ID.\n-- latitude [in]: (ignored if overload is a position string) the latitude.\n-- longitude [in]:(ignored if overload is a position string) the longitude.\n-- altitude [in]: (ignored if overload is a position string) the altitude.\n-- return: the class instance\n--\nPlanetaryReference.MapPosition    = mkMapPosition\n\n--\n-- PlanetarySystem - create an instance of PlanetarySystem class\n-- referenceData [in]: a table (indexed by bodyId) of body reference info.\n-- return: the class instance\n--\nPlanetaryReference.PlanetarySystem = mkPlanetarySystem\n\n--\n-- createBodyParameters - create an instance of BodyParameters class\n-- planetarySystemId  [in]: the body's planetary system ID.\n-- bodyId             [in]: the body's ID.\n-- surfaceArea        [in]: the body's surface area in square meters.\n-- aPosition          [in]: world coordinates of a position near the body.\n-- verticalAtPosition [in]: a vector pointing towards the body center.\n-- altitudeAtPosition [in]: the altitude in meters at the position.\n-- gravityAtPosition  [in]: the magnitude of the gravitational acceleration.\n-- return: an instance of BodyParameters class.\n--\nfunction PlanetaryReference.createBodyParameters(planetarySystemId,\n                                                 bodyId,\n                                                 surfaceArea,\n                                                 aPosition,\n                                                 verticalAtPosition,\n                                                 altitudeAtPosition,\n                                                 gravityAtPosition)\n    assert(isSNumber(planetarySystemId),\n           'Argument 1 (planetarySystemId) must be a number:' ..\n           type(planetarySystemId))\n    assert(isSNumber(bodyId),\n           'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n    assert(isSNumber(surfaceArea),\n           'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))\n    assert(isTable(aPosition),\n           'Argument 4 (aPosition) must be an array or vec3:' ..\n           type(aPosition))\n    assert(isTable(verticalAtPosition),\n           'Argument 5 (verticalAtPosition) must be an array or vec3:' ..\n           type(verticalAtPosition))\n    assert(isSNumber(altitudeAtPosition),\n           'Argument 6 (altitude) must be in meters:' ..\n           type(altitudeAtPosition))\n    assert(isSNumber(gravityAtPosition),\n           'Argument 7 (gravityAtPosition) must be number:' ..\n           type(gravityAtPosition))\n    local radius   = math.sqrt(surfaceArea/4/math.pi)\n    local distance = radius + altitudeAtPosition\n    local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)\n    local GM       = gravityAtPosition * distance * distance\n    return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)\nend\n\n--\n-- isMapPosition - check for the presence of the 'MapPosition' fields\n-- valueToTest [in]: the value to be checked\n-- return: 'true' if all required fields are present in the input value\n--\nPlanetaryReference.isMapPosition  = isMapPosition\n\n-- PlanetaryReference INSTANCE METHODS:\n\n--\n-- getPlanetarySystem - get the planetary system using ID or MapPosition as key\n-- overload [in]: either the planetary system ID or a MapPosition that has it.\n-- return: instance of 'PlanetarySystem' class or nil on error\n--\nfunction PlanetaryReference:getPlanetarySystem(overload)\n    --if galaxyAtlas then\n        local planetarySystemId = overload\n\n        if isMapPosition(overload) then\n            planetarySystemId = overload.systemId\n        end\n\n        if type(planetarySystemId) == 'number' then\n            local system = self.galaxyAtlas[i]\n            if system then\n                if getmetatable(nv) ~= PlanetarySystem then\n                    system = mkPlanetarySystem(system)\n                end\n                return system\n            end\n        end\n    --end\n    --return nil\nend\n\n-- PlanetarySystem INSTANCE METHODS:\n\n--\n-- castIntersections - Find the closest body that intersects a \"ray cast\".\n-- origin [in]: the origin of the \"ray cast\" in world coordinates\n-- direction [in]: the direction of the \"ray cast\" as a 'vec3' instance.\n-- sizeCalculator [in]: (default: returns 1.05*radius) Returns size given body.\n-- bodyIds[in]: (default: all IDs in system) check only the given IDs.\n-- return: The closest body that blocks the cast or 'nil' if none.\n--\nfunction PlanetarySystem:castIntersections(origin,\n                                           direction,\n                                           sizeCalculator,\n                                           bodyIds)\n    local sizeCalculator = sizeCalculator or \n                            function (body) return 1.05*body.radius end\n    local candidates = {}\n\n    if bodyIds then\n        for _,i in ipairs(bodyIds) do candidates[i] = self[i] end\n    else\n        bodyIds = {}\n        for k,body in pairs(self) do\n            table.insert(bodyIds, k)\n            candidates[k] = body\n        end\n    end\n    local function compare(b1,b2)\n        local v1 = candidates[b1].center - origin\n        local v2 = candidates[b2].center - origin\n        return v1:len() < v2:len()\n    end\n    table.sort(bodyIds, compare)\n    local dir = direction:normalize()\n\n    for i, id in ipairs(bodyIds) do\n        local body   = candidates[id]\n        local c_oV3  = body.center - origin\n        local radius = sizeCalculator(body)\n        local dot    = c_oV3:dot(dir)\n        local desc   = dot^2 - (c_oV3:len2() - radius^2)\n\n        if desc >= 0 then\n            local root     = math.sqrt(desc)\n            local farSide  = dot + root\n            local nearSide = dot - root\n            if nearSide > 0 then\n                return body, farSide, nearSide\n            elseif farSide > 0 then\n                return body, farSide, nil\n            end\n        end\n    end\n    return nil, nil, nil\nend\n\n--\n-- closestBody - find the closest body to a given set of world coordinates\n-- coordinates       [in]: the world coordinates of position in space\n-- return: an instance of the BodyParameters object closest to 'coordinates'\n--\nfunction PlanetarySystem:closestBody(coordinates)\n    assert(type(coordinates) == 'table', 'Invalid coordinates.')\n    local minDistance2, body\n    local coord = vec3(coordinates)\n\n    for _,params in pairs(self) do\n        local distance2 = (params.center - coord):len2()\n        if not body or distance2 < minDistance2 then\n            body         = params\n            minDistance2 = distance2\n        end\n    end\n    return body\nend\n\n--\n-- convertToBodyIdAndWorldCoordinates - map to body Id and world coordinates\n-- overload [in]: an instance of MapPosition or a position string ('::pos...)\n-- return: a vec3 instance containing the world coordinates or 'nil' on error.\n--\nfunction PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)\n    local mapPosition = overload\n    if isString(overload) then\n        mapPosition = mkMapPosition(overload)\n    end\n\n    if mapPosition.bodyId == 0 then\n        return 0, vec3(mapPosition.latitude,\n                       mapPosition.longitude,\n                       mapPosition.altitude)\n    end\n    local params = self:getBodyParameters(mapPosition)\n\n    if params then\n        return mapPosition.bodyId,\n               params:convertToWorldCoordinates(mapPosition)\n    end\nend\n\n--\n-- getBodyParameters - get or create an instance of BodyParameters class\n-- overload [in]: either an instance of MapPosition or a body's ID.\n-- return: a BodyParameters instance or 'nil' if body ID is not found.\n--\nfunction PlanetarySystem:getBodyParameters(overload)\n    local bodyId = overload\n\n    if isMapPosition(overload) then\n        bodyId = overload.bodyId\n    end\n    assert(isSNumber(bodyId),\n               'Argument 1 (bodyId) must be a number:' .. type(bodyId))\n\n    return self[bodyId]\nend\n\n--\n-- getPlanetarySystemId - get the planetary system ID for this instance\n-- return: the planetary system ID or nil if no planets are in the system.\n--\nfunction PlanetarySystem:getPlanetarySystemId()\n    local k, v = next(self)\n    return v and v.planetarySystemId\nend\n\n-- BodyParameters INSTANCE METHODS:\n\n--\n-- convertToMapPosition - create an instance of MapPosition from coordinates\n-- worldCoordinates [in]: the world coordinates of the map position.\n-- return: an instance of MapPosition class\n--\nfunction BodyParameters:convertToMapPosition(worldCoordinates)\n    assert(isTable(worldCoordinates),\n           'Argument 1 (worldCoordinates) must be an array or vec3:' ..\n           type(worldCoordinates))\n    local worldVec  = vec3(worldCoordinates) \n\n    if self.bodyId == 0 then\n        return setmetatable({latitude  = worldVec.x,\n                             longitude = worldVec.y,\n                             altitude  = worldVec.z,\n                             bodyId    = 0,\n                             systemId  = self.planetarySystemId}, MapPosition)\n    end\n    local coords    = worldVec - self.center\n    local distance  = coords:len()\n    local altitude  = distance - self.radius\n    local latitude  = 0\n    local longitude = 0\n\n    if not float_eq(distance, 0) then\n        local phi = math.atan(coords.y, coords.x)\n        longitude = phi >= 0 and phi or (2*math.pi + phi)\n        latitude  = math.pi/2 - math.acos(coords.z/distance)\n    end\n    return setmetatable({latitude  = latitude,\n                         longitude = longitude,\n                         altitude  = altitude,\n                         bodyId    = self.bodyId,\n                         systemId  = self.planetarySystemId}, MapPosition)\nend\n\n--\n-- convertToWorldCoordinates - convert a map position to world coordinates\n-- overload [in]: an instance of MapPosition or a position string ('::pos...')\n--\nfunction BodyParameters:convertToWorldCoordinates(overload)\n    local mapPosition = isString(overload) and\n                                           mkMapPosition(overload) or overload\n    if mapPosition.bodyId == 0 then -- support deep space map position\n        return vec3(mapPosition.latitude,\n                    mapPosition.longitude,\n                    mapPosition.altitude)\n    end\n    assert(isMapPosition(mapPosition),\n           'Argument 1 (mapPosition) is not an instance of \"MapPosition\".')\n    assert(mapPosition.systemId == self.planetarySystemId,\n           'Argument 1 (mapPosition) has a different planetary system ID.')\n    assert(mapPosition.bodyId == self.bodyId,\n           'Argument 1 (mapPosition) has a different planetary body ID.')\n    local xproj = math.cos(mapPosition.latitude)\n    return self.center + (self.radius + mapPosition.altitude) *\n           vec3(xproj*math.cos(mapPosition.longitude),\n                xproj*math.sin(mapPosition.longitude),\n                math.sin(mapPosition.latitude))\nend\n\n--\n-- getAltitude - calculate the altitude of a point given in world coordinates.\n-- worldCoordinates [in]: the world coordinates of the point.\n-- return: the altitude in meters\n--\nfunction BodyParameters:getAltitude(worldCoordinates)\n    return (vec3(worldCoordinates) - self.center):len() - self.radius\nend\n\n--\n-- getDistance - calculate the distance to a point given in world coordinates.\n-- worldCoordinates [in]: the world coordinates of the point.\n-- return: the distance in meters\n--\nfunction BodyParameters:getDistance(worldCoordinates)\n    return (vec3(worldCoordinates) - self.center):len()\nend\n\n--\n-- getGravity - calculate the gravity vector induced by the body.\n-- worldCoordinates [in]: the world coordinates of the point.\n-- return: the gravity vector in meter/seconds^2\n--\nfunction BodyParameters:getGravity(worldCoordinates)\n    local radial = self.center - vec3(worldCoordinates) -- directed towards body\n    local len2   = radial:len2()\n    return (self.GM/len2) * radial/math.sqrt(len2)\nend\n\n-- end of module\n\nreturn setmetatable(PlanetaryReference,\n                    { __call = function(_,...)\n                                    return mkPlanetaryReference(...)\n                               end })\n\n\nend\n\n\n\n\n\n\n\nfunction Keplers()\n\t--[[ \n  Provides methods for computing orbital information for an object\n\n  Usage:\n  Kepler = require('autoconf.custom.kepler')\n  alioth = Kepler({ GM=157470826617,\n                    bodyId=2,\n                    center={x=-8.000,y=-8.000,z=-126303.000},\n                    name='Alioth',\n                    planetarySystemId=0,\n                    radius=126068\n                  })\n  altitude = 6000\n  position = '::pos{0,2,0,0,6000}'\n\n  e, o     = alioth:escapeAndOrbitalSpeed(altitude)\n  orbit    = alioth:orbitalParameters(position, {0, o+1, 0})\n\n  print(\"Eccentricity \" .. orbit.eccentricity)\n  print(\"Perihelion \" .. orbit.periapsis.altitude)\n  print(\"Max. speed \" .. orbit.periapsis.speed)\n  print(\"Circular orbit speed \" .. orbit.periapsis.circularOrbitSpeed)\n  print(\"Aphelion \"  .. orbit.apoapsis.altitude)\n  print(\"Min. speed \" .. orbit.apoapsis.speed)\n  print(\"Orbital period \" .. orbit.period)\n  --- output:\n    Eccentricity 0.0018324307017878\n    Perihelion 6000.0\n    Max. speed 1092.9462297033\n    Circular orbit speed 1091.9462297033\n    Aphelion 6484.8994605062\n    Min. speed 1088.9480596194\n    Orbital period 762.02818214049\n\n  Methods:\n    Kepler:escapeAndOrbitalSpeed - for a given celestial body and altitude.\n    Kepler:orbitalParameters - for a given massless object and a celestial body.\n\n  Description\n  The motion of an object in the vicinity of substantially larger mass is\n  in the domain of the \"2-body problem\". By assuming the object whose motion\n  is of interest is of negligable mass simplifies the calculations of:\n  the speed to escape the body, the speed of a circular orbit, and the\n  parameters defining the orbit of the object (or the lack of orbit as the\n  case may be).\n\n  Orbital Parameters:\n     periapsis - the closest approach to the planet\n      apoapsis - the furthest point from the planet if in orbit (otherwise nil)\n  eccentricity - 0 for circular orbits\n                <1 for elliptical orbits\n                 1 for parabiolic trajectory\n                >1 for hyperbolic trajectory\n        period - time (in seconds) to complete an orbit\n\n  Also See: planetref.lua\n]]--\n\nlocal vec3       = require('cpml.vec3')\nlocal PlanetRef  = PlanetRef()\n\nlocal function isString(s) return type(s)   == 'string' end\nlocal function isTable(t)  return type(t)   == 'table'  end\n\nlocal function float_eq(a,b)\n    if a == 0 then return math.abs(b) < 1e-09 end\n    if b == 0 then return math.abs(a) < 1e-09 end\n    return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon\nend\n\nKepler = {}\nKepler.__index = Kepler\n\n--\n-- escapeAndOrbitalSpeed - speed required to escape and for a circular orbit\n-- altitude [in]: the height of the orbit in meters above \"sea-level\"\n-- return: the speed in m/s needed to escape the celestial body and to orbit it.\n--\nfunction Kepler:escapeAndOrbitalSpeed(altitude)\n    assert(self.body)\n    -- P = -GMm/r and KE = mv^2/2 (no lorentz factor used)\n    -- mv^2/2 = GMm/r\n    -- v^2 = 2GM/r\n    -- v = sqrt(2GM/r1)\n    local distance = altitude + self.body.radius\n\n    if not float_eq(distance, 0) then\n        local orbit = math.sqrt(self.body.GM/distance)\n        return math.sqrt(2)*orbit, orbit\n    end\n    return nil, nil\nend\n\n--\n-- orbitalParameters: determine the orbital elements for a two-body system.\n-- overload [in]: the world coordinates or map coordinates of a massless object.\n-- velocity [in]: The velocity of the massless point object in m/s.\n-- return: the 6 orbital elements for the massless object.\n--\nfunction Kepler:orbitalParameters(overload, velocity)\n    -- I think maybe the first call to this fails?\n    -- Try to make that not happen\n    --if self.body == nil then\n    --\treturn nil     \n    --end\n    assert(self.body)\n    assert(isTable(overload) or isString(overload))\n    assert(isTable(velocity))\n    local pos = (isString(overload) or PlanetRef.isMapPosition(overload)) and\n                            self.body:convertToWorldCoordinates(overload) or\n                vec3(overload)\n    local v   = vec3(velocity)\n    local r   = pos - self.body.center\n    local v2  = v:len2()\n    local d   = r:len()\n    local mu  = self.body.GM\n    local e   = ((v2 - mu/d)*r - r:dot(v)*v)/mu\n    local a   = mu/(2*mu/d - v2)\n\n    local ecc = e:len()\n    local dir = e:normalize()\n    local pd  = a*(1-ecc)\n    local ad  = a*(1+ecc)\n    local per = pd*dir + self.body.center\n    local apo = ecc <= 1 and -ad*dir + self.body.center or nil\n    local trm = math.sqrt(a*mu*(1-ecc*ecc))\n\n    return { periapsis       = { position           = per,\n                                 speed              = trm/pd,\n                                 circularOrbitSpeed = math.sqrt(mu/pd),\n                                 altitude           = pd - self.body.radius},\n             apoapsis        = apo and\n                               { position           = apo,\n                                 speed              = trm/ad,\n                                 circularOrbitSpeed = math.sqrt(mu/ad),\n                                 altitude           = ad - self.body.radius},\n             currentVelocity = v,\n             currentPosition = pos,\n             eccentricity    = ecc,\n             period          = apo and 2*math.pi*math.sqrt(a^3/mu),\n           }\nend\n\nlocal function new(bodyParameters)\n    local params = PlanetRef.BodyParameters(bodyParameters.planetarySystemId,\n                                            bodyParameters.bodyId,\n                                            bodyParameters.radius,\n                                            bodyParameters.center,\n                                            bodyParameters.GM)\n    return setmetatable({body = params}, Kepler)\nend\n\nreturn setmetatable(Kepler, { __call = function(_,...) return new(...) end })\n\nend\n\n\nfunction Kinematics()\n\t--[[ \n  DualUniverse kinematic equations\n  Author: JayleBreak\n\n  Usage (unit.start):\n  Kinematics = require('autoconf.custom.kinematics')\n\n  Methods:\n   computeAccelerationTime - \"relativistic\" version of t = (vf - vi)/a\n   computeDistanceAndTime - Return distance & time needed to reach final speed.\n   computeTravelTime - \"relativistic\" version of t=(sqrt(2ad+v^2)-v)/a\n\n  Description\n  DualUniverse increases the effective mass of constructs as their absolute\n  speed increases by using the \"lorentz\" factor (from relativity) as the scale\n  factor.  This results in an upper bound on the absolute speed of constructs\n  (excluding \"warp\" drive) that is set to 30 000 KPH (8 333 MPS). This module\n  provides utilities for computing some physical quantities taking this\n  scaling into account.\n]]--\n\nlocal Kinematic = {} -- just a namespace\n\nlocal C       = 30000000/3600\nlocal C2      = C*C\nlocal ITERATIONS = 100 -- iterations over engine \"warm-up\" period\n\nlocal function lorentz(v) return 1/math.sqrt(1 - v*v/C2) end\n\n--\n-- computeAccelerationTime - \"relativistic\" version of t = (vf - vi)/a\n-- initial      [in]: initial (positive) speed in meters per second.\n-- acceleration [in]: constant acceleration until 'finalSpeed' is reached.\n-- final        [in]: the speed at the end of the time interval.\n-- return: the time in seconds spent in traversing the distance\n--\nfunction Kinematic.computeAccelerationTime(initial, acceleration, final)\n    -- The low speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)\n    local k1 = C*math.asin(initial/C)\n    return (C * math.asin(final/C) - k1)/acceleration\nend\n\n--\n-- computeDistanceAndTime - Return distance & time needed to reach final speed.\n-- initial[in]:     Initial speed in meters per second.\n-- final[in]:       Final speed in meters per second.\n-- restMass[in]:    Mass of the construct at rest in Kg.\n-- thrust[in]:      Engine's maximum thrust in Newtons.\n-- t50[in]:         (default: 0) Time interval to reach 50% thrust in seconds.\n-- brakeThrust[in]: (default: 0) Constant thrust term when braking.\n-- return: Distance (in meters), time (in seconds) required for change.\n--\nfunction Kinematic.computeDistanceAndTime(initial,\n                                          final,\n                                          restMass,\n                                          thrust,\n                                          t50,\n                                          brakeThrust)\n    -- This function assumes that the applied thrust is colinear with the\n    -- velocity. Furthermore, it does not take into account the influence\n    -- of gravity, not just in terms of its impact on velocity, but also\n    -- its impact on the orientation of thrust relative to velocity.\n    -- These factors will introduce (usually) small errors which grow as\n    -- the length of the trip increases.\n    t50            = t50 or 0\n    brakeThrust    = brakeThrust or 0 -- usually zero when accelerating\n\n    local tau0     = lorentz(initial)\n    local speedUp  = initial <= final\n    local a0       = thrust * (speedUp and 1 or -1)/restMass\n    local b0       = -brakeThrust/restMass\n    local totA     = a0+b0\n\n    if speedUp and totA <= 0 or not speedUp and totA >= 0 then\n        return -1, -1 -- no solution\n    end\n\n    local distanceToMax, timeToMax = 0, 0\n\n    -- If, the T50 time is set, then assume engine is at zero thrust and will\n    -- reach full thrust in 2*T50 seconds. Thrust curve is given by:\n    -- Thrust: F(z)=(a0*(1+sin(z))+2*b0)/2 where z=pi*(t/t50 - 1)/2\n    -- Acceleration is given by F(z)/m(z) where m(z) = m/sqrt(1-v^2/c^2)\n    -- or v(z)' = (a0*(1+sin(z))+2*b0)*sqrt(1-v(z)^2/c^2)/2\n\n    if a0 ~= 0 and t50 > 0 then\n        -- Closed form solution for velocity exists:\n        -- v(t) = -c*tan(w)/sqrt(tan(w)^2+1) => w = -asin(v/c)\n        -- w=(pi*t*(a0/2+b0)-a0*t50*sin(pi*t/2/t50)+*pi*c*k1)/pi/c\n        -- @ t=0, v(0) = vi\n        -- pi*c*k1/pi/c = -asin(vi/c)\n        -- k1 = asin(vi/c)\n        local k1  = math.asin(initial/C)\n\n        local c1  = math.pi*(a0/2+b0)\n        local c2  = a0*t50\n        local c3  = C*math.pi\n\n        local v = function(t)\n            local w  = (c1*t - c2*math.sin(math.pi*t/2/t50) + c3*k1)/c3\n            local tan = math.tan(w)\n            return C*tan/math.sqrt(tan*tan+1)\n        end\n\n        local speedchk = speedUp and function(s) return s >= final end or\n                                     function(s) return s <= final end\n        timeToMax  = 2*t50\n\n        if speedchk(v(timeToMax)) then\n            local lasttime = 0\n\n            while math.abs(timeToMax - lasttime) > 0.5 do\n                local t = (timeToMax + lasttime)/2\n                if speedchk(v(t)) then\n                    timeToMax = t \n                else\n                    lasttime = t\n                end\n            end\n        end\n\n        -- There is no closed form solution for distance in this case.\n        -- Numerically integrate for time t=0 to t=2*T50 (or less)\n        local lastv = initial\n        local tinc  = timeToMax/ITERATIONS\n\n        for step = 1, ITERATIONS do\n            local speed = v(step*tinc)\n            distanceToMax = distanceToMax + (speed+lastv)*tinc/2\n            lastv = speed\n        end\n\n        if timeToMax < 2*t50 then\n            return distanceToMax, timeToMax\n        end\n        initial     = lastv\n    end\n    -- At full thrust, acceleration only depends on the Lorentz factor:\n    -- v(t)' = (F/m(v)) = a*sqrt(1-v(t)^2/c^2) where a = a0+b0\n    -- -> v = c*sin((at+k1)/c)\n    -- @ t=0, v=vi: k1 = c*asin(vi/c)\n    -- -> t = (c*asin(v/c) - k1)/a\n    -- x(t)' = c*sin((at+k1)/c)\n    -- x = k2 - c^2 cos((at+k1)/c)/a\n    -- @ t=0, x=0: k2 = c^2 * cos(k1/c)/a\n    local k1       = C*math.asin(initial/C)\n    local time     = (C * math.asin(final/C) - k1)/totA\n\n    local k2       = C2 *math.cos(k1/C)/totA\n    local distance = k2 - C2 * math.cos((totA*time + k1)/C)/totA\n\n    return distance+distanceToMax, time+timeToMax\nend\n\n--\n-- computeTravelTime - \"relativistic\" version of t=(sqrt(2ad+v^2)-v)/a\n-- initialSpeed [in]: initial (positive) speed in meters per second\n-- acceleration [in]: constant acceleration until 'distance' is traversed\n-- distance [in]: the distance traveled in meters\n-- return: the time in seconds spent in traversing the distance\n--\nfunction Kinematic.computeTravelTime(initial, acceleration, distance)\n    -- The low speed limit of following is: t=(sqrt(2ad+v^2)-v)/a\n    -- (from: d=vt+at^2/2)\n    if distance == 0 then return 0 end\n\n    if acceleration > 0 then\n        local k1       = C*math.asin(initial/C)\n        local k2       = C2*math.cos(k1/C)/acceleration\n        return (C*math.acos(acceleration*(k2 - distance)/C2) - k1)/acceleration\n    end\n    assert(initial > 0, 'Acceleration and initial speed are both zero.')\n    return distance/initial\nend\n\nfunction Kinematic.lorentz(v) return lorentz(v) end\n\nreturn Kinematic\n\nend\n\n\nPlanetaryReference = PlanetRef()\ngalaxyReference = PlanetaryReference(Atlas())\nKinematic = Kinematics()\nAutopilotTargetIndex = 0\nAutopilotTargetName = \"None\"\nAutopilotTargetPlanet = nil\nMaxGameVelocity = 8333.0556\n\nfunction getDistanceDisplayString(distance)\n\tlocal su = distance > 100000\n\tlocal result = \"\"\n\tif su then\n\t\t-- Convert to SU\n\t\tresult = round(distance/1000/200,2) .. \" SU\"\n\telse\n\t\t-- Convert to KM\n\t\tresult = round(distance/1000,2) .. \" KM\"\n\tend\n\t\n\treturn result\nend\n\nfunction getSpeedDisplayString(speed) -- TODO: Allow options, for now just do kph\n\treturn round(speed*3.6,2) .. \" km/h\"\nend\n\nfunction FormatTimeString(seconds)\n\tlocal hours = math.floor(seconds/3600)\n\tlocal minutes = math.floor(seconds/60%60)\n\tlocal seconds = math.floor(seconds%60)\n\treturn hours .. \"h \" .. minutes .. \"m\" .. seconds .. \"s\"\nend\n\nfunction UpdateAutopilotTarget()\n\t-- So the indices are weird.  I think we need to do a pairs\n\tif AutopilotTargetIndex == 0 then\n\t\tAutopilotTargetName = \"None\"\n\t\tAutopilotTargetPlanet = nil\n\t\treturn true\n\tend\n\tlocal count = 0\n\tfor k,v in pairs(Atlas()[0]) do\n\t\tcount = count + 1\n\t\tif count == AutopilotTargetIndex then\n\t\t\tAutopilotTargetName = v.name .. \" (\" .. getDistanceDisplayString(galaxyReference[0][k]:getDistance(core.getConstructWorldPos())) .. \")\"\n\t\t\tAutopilotTargetPlanet = galaxyReference[0][k]\n\t\t\treturn true\n\t\tend\n\tend\n\tsystem.print(\"Error: Autopilot index was outside the bounds of the target range\")\n\treturn false\nend\n\nfunction IncrementAutopilotTargetIndex()\n\tAutopilotTargetIndex = AutopilotTargetIndex + 1\n\tif AutopilotTargetIndex >  tablelength(Atlas()[0]) then \n\t\tAutopilotTargetIndex = 0\n\tend\n\tUpdateAutopilotTarget()\nend\n\nfunction DecrementAutopilotTargetIndex()\n\tAutopilotTargetIndex = AutopilotTargetIndex - 1\n\tif AutopilotTargetIndex < 0 then \n\t\tAutopilotTargetIndex = tablelength(Atlas()[0])\n\tend\n\tUpdateAutopilotTarget()\nend\n\nfunction GetAutopilotTravelTime()\n\tAutopilotDistance = (AutopilotTargetPlanet.center - vec3(core.getConstructWorldPos())):len()\n\tlocal velocity = core.getWorldVelocity() \n\tlocal accelDistance, accelTime = Kinematic.computeDistanceAndTime(vec3(velocity):len(),\n\t\t8333.0556, -- From currently velocity to max\n\t\tcore.getConstructMass(),\n\t\tNav:maxForceForward(),\n\t\t0, -- T50?  Assume none, negligible for this\n\t\t0) -- Brake thrust, none for this\n\t-- accelDistance now has the amount of distance for which we will be accelerating\n\t-- Then we need the distance we'd brake from full speed\n\t-- Note that for some nearby moons etc, it may never reach full speed though.\n\tlocal brakeDistance, brakeTime = GetAutopilotBrakeDistanceAndTime(8333.0556) -- Round up for this\n\tlocal cruiseDistance = 0\n    local cruiseTime = 0\n\tif brakeDistance + accelDistance < AutopilotDistance then \n\t\t-- Add any remaining distance\n\t\tcruiseDistance = AutopilotDistance - (brakeDistance + accelDistance)\n\t\tcruiseTime = Kinematic.computeTravelTime(8333.0556, 0, cruiseDistance)\n\tend\n\t-- TODO: Find some way to mark it as potentially inaccurate if this previous condition wasn't met\n\t-- So, time is in seconds\n\tif AutopilotBraking then\n\t\treturn brakeTime\n\telseif AutopilotCruising then\n\t\treturn cruiseTime + brakeTime\n\telse\n\t\treturn accelTime + brakeTime + cruiseTime\n\tend\nend\n\n\nfunction GetAutopilotBrakeDistanceAndTime(speed) -- Aim for 0 ending velocity, even though it'll probably be higher than that in most cases\n\treturn Kinematic.computeDistanceAndTime(speed, 0, core.getConstructMass(), 0, 0, json.decode(unit.getData()).maxBrake)\nend\n\nfunction round(num, numDecimalPlaces)\n  local mult = 10^(numDecimalPlaces or 0)\n  return math.floor(num * mult + 0.5) / mult\nend\n\nfunction tablelength(T)\n  local count = 0\n  for _ in pairs(T) do count = count + 1 end\n  return count\nend","filter":{"args":[],"signature":"start()","slotKey":"-2"},"key":"19"},{"code":"Nav:update()","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":"20"},{"code":"-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\nlocal finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\nlocal finalRollInput = rollInput + system.getControlDeviceYawInput()\nlocal finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\nlocal finalBrakeInput = brakeInput\n\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(core.getConstructWorldOrientationUp())\nlocal constructForward = vec3(core.getConstructWorldOrientationForward())\nlocal constructRight = vec3(core.getConstructWorldOrientationRight())\nlocal constructVelocity = vec3(core.getWorldVelocity())\nlocal constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\n-- Rotation\nlocal constructAngularVelocity = vec3(core.getWorldAngularVelocity())\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 1.0\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n","filter":{"args":[],"signature":"flush()","slotKey":"-2"},"key":"21"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"forward"}],"signature":"actionStart(forward)","slotKey":"-2"},"key":"22"},{"code":"gearExtended = not gearExtended\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n","filter":{"args":[{"value":"gear"}],"signature":"actionStart(gear)","slotKey":"-2"},"key":"23"},{"code":"if Nav.control.isAnyHeadlightSwitchedOn() == 1 then\n    Nav.control.switchOffHeadlights()\nelse\n    Nav.control.switchOnHeadlights()\nend\n","filter":{"args":[{"value":"light"}],"signature":"actionStart(light)","slotKey":"-2"},"key":"24"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"forward"}],"signature":"actionStop(forward)","slotKey":"-2"},"key":"25"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"backward"}],"signature":"actionStart(backward)","slotKey":"-2"},"key":"26"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"backward"}],"signature":"actionStop(backward)","slotKey":"-2"},"key":"27"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"left"}],"signature":"actionStart(left)","slotKey":"-2"},"key":"28"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"left"}],"signature":"actionStop(left)","slotKey":"-2"},"key":"29"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"right"}],"signature":"actionStart(right)","slotKey":"-2"},"key":"30"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"straferight"}],"signature":"actionStart(straferight)","slotKey":"-2"},"key":"31"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"right"}],"signature":"actionStop(right)","slotKey":"-2"},"key":"32"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"straferight"}],"signature":"actionStop(straferight)","slotKey":"-2"},"key":"33"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"actionLoop(groundaltitudedown)","slotKey":"-2"},"key":"34"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawright"}],"signature":"actionStart(yawright)","slotKey":"-2"},"key":"35"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawright"}],"signature":"actionStop(yawright)","slotKey":"-2"},"key":"36"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawleft"}],"signature":"actionStart(yawleft)","slotKey":"-2"},"key":"37"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawleft"}],"signature":"actionStop(yawleft)","slotKey":"-2"},"key":"38"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"down"}],"signature":"actionStop(down)","slotKey":"-2"},"key":"39"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"actionStart(groundaltitudeup)","slotKey":"-2"},"key":"40"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"actionLoop(groundaltitudeup)","slotKey":"-2"},"key":"41"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"actionStart(groundaltitudedown)","slotKey":"-2"},"key":"42"},{"code":"IncrementAutopilotTargetIndex()","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"43"},{"code":"DecrementAutopilotTargetIndex()","filter":{"args":[{"value":"option2"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"44"}],"methods":[],"events":[]}
